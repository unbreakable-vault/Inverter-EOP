// PMOD-Thingy (ATmega32U4 @ 3.3V / 8 MHz)
// Boot: quadruple strobe -> D2 ON + D1 OFF (sys_clk LOW)
// '1' press #1: sys_clk HIGH -> heartbeat pattern (both LEDs pulse together)
// '1' press #2: sys_clk LOW  -> D1 ON + D2 OFF
// Messages: "sys_clk -> HIGH" or "sys_clk -> LOW" in Serial Monitor

#define LED_D1 LED_BUILTIN_RX   // PC6, active-low
#define LED_D2 LED_BUILTIN_TX   // PC7, active-low
static constexpr bool LED_ACTIVE_LOW = true;

enum { JA1_BIT = 1 };           // JA1 bit on PORT_JA

// LED helpers
inline void ledWrite(uint8_t pin, bool on) {
  digitalWrite(pin, LED_ACTIVE_LOW ? (on ? LOW : HIGH) : (on ? HIGH : LOW));
}
inline void ledsBoth(bool on) { ledWrite(LED_D1, on); ledWrite(LED_D2, on); }

// modes
enum LedMode { SOLID_D1_ON_D2_OFF, HEARTBEAT_BOTH, SOLID_D2_ON_D1_OFF };
LedMode mode = SOLID_D1_ON_D2_OFF;
bool sysclk_high = false;

// heartbeat state
unsigned long t_next = 0;
uint8_t step_idx = 0;

// quadruple strobe
void quadStrobe() {
  for (uint8_t i = 0; i < 4; ++i) {
    ledsBoth(true);  delay(60);   // ON
    ledsBoth(false); delay(60);   // OFF
  }
}

// heartbeat animation (non-blocking)
void serviceHeartbeat() {
  unsigned long now = millis();
  if (now < t_next) return;
  switch (step_idx) {
    case 0: ledsBoth(true);   t_next = now + 140; step_idx = 1; break; // beat 1
    case 1: ledsBoth(false);  t_next = now + 140; step_idx = 2; break; // gap
    case 2: ledsBoth(true);   t_next = now +  90; step_idx = 3; break; // beat 2
    case 3: ledsBoth(false);  t_next = now + 700; step_idx = 0; break; // rest
  }
}

// set sys_clk and mode
void set_sysclk(bool high) {
  if (high) {
    PORT_JA |=  (1 << JA1_BIT);
    sysclk_high = true;
    mode = HEARTBEAT_BOTH;
    step_idx = 0; t_next = 0;
    Serial.println("sys_clk -> HIGH");
  } else {
    PORT_JA &= ~(1 << JA1_BIT);
    sysclk_high = false;
    mode = SOLID_D2_ON_D1_OFF;
    Serial.println("sys_clk -> LOW");
  }
}

void setup() {
  pinMode(LED_D1, OUTPUT);
  pinMode(LED_D2, OUTPUT);

  // boot animation
  quadStrobe();
  ledWrite(LED_D1, true);   // D1 ON
  ledWrite(LED_D2, false);  // D2 OFF

  Serial.begin(9600);
  // JA1 as output, start LOW
  DDR_JA |= (1 << JA1_BIT);
  PORT_JA &= ~(1 << JA1_BIT);
  sysclk_high = false;
  mode = SOLID_D1_ON_D2_OFF;

  Serial.println("Ready. Press '1' to toggle sys_clk.");
}

void loop() {
  if (Serial.available()) {
    char c = Serial.read();
    if (c == '1') {
      set_sysclk(!sysclk_high);
      // apply static LED states immediately
      if (mode == SOLID_D1_ON_D2_OFF) {
        ledWrite(LED_D1, true);
        ledWrite(LED_D2, false);
      } else if (mode == SOLID_D2_ON_D1_OFF) {
        ledWrite(LED_D2, true);
        ledWrite(LED_D1, false);
      }
    }
  }

  // run animations
  if (mode == HEARTBEAT_BOTH) {
    serviceHeartbeat();
  } else if (mode == SOLID_D1_ON_D2_OFF) {
    ledWrite(LED_D1, true);
    ledWrite(LED_D2, false);
  } else if (mode == SOLID_D2_ON_D1_OFF) {
    ledWrite(LED_D2, true);
    ledWrite(LED_D1, false);
  }
}
